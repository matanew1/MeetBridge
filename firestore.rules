rules_version = '2';
service cloud.firestore {
  match /databases/{database}/documents {
    // [SECURITY] Helper functions for validation
    function isAuthenticated() {
      return request.auth != null;
    }
    
    function isOwner(userId) {
      return isAuthenticated() && request.auth.uid == userId;
    }
    
    function isValidString(value, minLen, maxLen) {
      return value is string && value.size() >= minLen && value.size() <= maxLen;
    }
    
    function isValidEmail(email) {
      return email is string && email.matches('^[\\w-\\.]+@([\\w-]+\\.)+[\\w-]{2,4}$');
    }
    
    function hasValidTimestamp() {
      return request.resource.data.keys().hasAll(['createdAt', 'updatedAt']) 
        && request.time == request.resource.data.createdAt
        && request.time == request.resource.data.updatedAt;
    }
    
    // [SECURITY FIX] Users collection - strict validation and access control
    match /users/{userId} {
      // Users can read their own profile and other users' public profiles
      allow read: if isAuthenticated();
      
      // [SECURITY] Users can only create/update their own profile with validation
      // Note: Check required fields exist, not that ONLY these fields exist
      allow create: if isOwner(userId) 
        && isValidString(request.resource.data.name, 2, 50)
        && isValidEmail(request.resource.data.email)
        && request.resource.data.age >= 18 && request.resource.data.age <= 120
        && request.resource.data.name is string
        && request.resource.data.email is string
        && request.resource.data.age is number
        && request.resource.data.createdAt == request.time;
      
      // [SECURITY FIX] Allow updates with proper validation
      allow update: if isOwner(userId)
        // Prevent changing immutable fields
        && (!request.resource.data.diff(resource.data).affectedKeys().hasAny(['id', 'email', 'createdAt']))
        // Allow automatic fields (location, status, timestamps)
        && (
          // Age validation if being updated
          !request.resource.data.diff(resource.data).affectedKeys().hasAny(['age']) 
          || (request.resource.data.age >= 18 && request.resource.data.age <= 120)
        )
        // Name validation if being updated
        && (
          !request.resource.data.diff(resource.data).affectedKeys().hasAny(['name'])
          || isValidString(request.resource.data.name, 2, 50)
        );
      
      // [SECURITY] Users cannot delete their own profiles (use backend admin API)
      allow delete: if false;
    }
    
    // [SECURITY FIX] Discovery queue - strict access control
    match /discovery_queue/{queueId} {
      allow read: if isAuthenticated() && isOwner(resource.data.userId);
      allow create: if isAuthenticated() && isOwner(request.resource.data.userId);
      allow update: if isAuthenticated() && isOwner(resource.data.userId);
      allow delete: if isAuthenticated() && isOwner(resource.data.userId);
    }

    // [SECURITY FIX] Missed Connections - enhanced validation and rate limiting
    match /missed_connections/{connectionId} {
      // [SECURITY] Anyone authenticated can read connections
      allow read: if isAuthenticated();
      
      // [SECURITY] Validate connection creation with proper fields
      // Note: Using hasAll() to check required fields exist, not that ONLY these fields exist
      allow create: if isAuthenticated() 
        && isOwner(request.resource.data.userId)
        && isValidString(request.resource.data.description, 10, 1000)
        && request.resource.data.likes == 0
        && request.resource.data.views == 0
        && request.resource.data.userId is string
        && request.resource.data.description is string
        && request.resource.data.location != null
        && request.resource.data.createdAt == request.time;
      
      // [SECURITY] Owner can update OR authenticated users can update likes/views only
      allow update: if isAuthenticated() && (
        isOwner(resource.data.userId) ||
        // [SECURITY] Restrict which fields can be updated by non-owners
        (request.resource.data.diff(resource.data).affectedKeys().hasOnly(['likes', 'likedBy', 'views', 'viewedBy', 'claims', 'comments', 'savedBy'])
          && request.resource.data.likes >= resource.data.likes  // Likes can only increment
          && request.resource.data.views >= resource.data.views) // Views can only increment
      );
      
      // [SECURITY] Only the owner can delete their connection
      allow delete: if isAuthenticated() && isOwner(resource.data.userId);
      
      // [SECURITY] Comments subcollection
      match /comments/{commentId} {
        // Anyone can read comments
        allow read: if isAuthenticated();
        
        // Validate comment creation
        allow create: if isAuthenticated()
          && isOwner(request.resource.data.userId)
          && isValidString(request.resource.data.text, 1, 500)
          && request.resource.data.userId is string
          && request.resource.data.text is string
          && request.resource.data.createdAt == request.time;
        
        // Only comment author can update/delete
        allow update, delete: if isAuthenticated() && isOwner(resource.data.userId);
      }
    }

    // [SECURITY FIX] Missed Connection Claims - strict validation
    match /missed_connection_claims/{claimId} {
      // [SECURITY] Only connection owner and claimer can read
      allow read: if isAuthenticated() && (
        isOwner(resource.data.claimerId) ||
        isOwner(resource.data.connectionOwnerId)
      );
      
      // [SECURITY] Validate claim creation
      allow create: if isAuthenticated() 
        && isOwner(request.resource.data.claimerId)
        && isValidString(request.resource.data.message, 10, 500)
        && request.resource.data.claimerId is string
        && request.resource.data.connectionId is string
        && request.resource.data.connectionOwnerId is string
        && request.resource.data.message is string
        && request.resource.data.status == 'pending'
        && request.resource.data.createdAt == request.time;
      
      // [SECURITY] Only connection owner can update claim status
      allow update: if isAuthenticated() 
        && isOwner(resource.data.connectionOwnerId)
        && request.resource.data.diff(resource.data).affectedKeys().hasOnly(['status', 'updatedAt']);
      
      // [SECURITY] Only the claimer can delete their claim
      allow delete: if isAuthenticated() && isOwner(resource.data.claimerId);
    }
    
    // [SECURITY FIX] Conversations - strict access control
    match /conversations/{conversationId} {
      // [SECURITY] Only participants can access conversation
      allow read: if isAuthenticated() && request.auth.uid in resource.data.participants;
      
      allow create: if isAuthenticated() 
        && request.auth.uid in request.resource.data.participants
        && request.resource.data.participants.size() == 2;
      
      allow update: if isAuthenticated() && request.auth.uid in resource.data.participants;
      
      allow delete: if false; // Conversations should not be deleted
      
      // [SECURITY] Messages subcollection
      match /messages/{messageId} {
        // [SECURITY] Only participants can read messages
        allow read: if isAuthenticated() 
          && request.auth.uid in get(/databases/$(database)/documents/conversations/$(conversationId)).data.participants;
        
        // [SECURITY] Validate message creation
        allow create: if isAuthenticated()
          && request.auth.uid in get(/databases/$(database)/documents/conversations/$(conversationId)).data.participants
          && isOwner(request.resource.data.senderId)
          && isValidString(request.resource.data.text, 1, 5000)
          && request.resource.data.senderId is string
          && request.resource.data.text is string
          && request.resource.data.createdAt == request.time;
        
        // [SECURITY] Messages cannot be updated or deleted
        allow update, delete: if false;
      }
    }
    
    // [SECURITY FIX] Matches - strict access control
    match /matches/{matchId} {
      allow read: if isAuthenticated() && (
        isOwner(resource.data.user1) || isOwner(resource.data.user2)
      );
      
      allow create: if isAuthenticated() && (
        isOwner(request.resource.data.user1) || isOwner(request.resource.data.user2)
      );
      
      allow update: if isAuthenticated() && (
        isOwner(resource.data.user1) || isOwner(resource.data.user2)
      );
      
      allow delete: if false; // Matches should not be deleted
    }
    
    // [SECURITY FIX] Interactions - track likes, dislikes, winks
    match /interactions/{interactionId} {
      // [SECURITY] Users can read their own interactions
      allow read: if isAuthenticated() && (
        isOwner(resource.data.userId) || 
        request.auth.uid == resource.data.targetUserId
      );
      
      // [SECURITY] Validate interaction creation - allow any authenticated user to create
      allow create: if isAuthenticated()
        && isOwner(request.resource.data.userId)
        && request.resource.data.type in ['like', 'dislike', 'wink']
        && request.resource.data.targetUserId is string
        && request.resource.data.targetUserId.size() > 0;
      
      // [SECURITY] Users can update their own interactions
      allow update: if isAuthenticated() && isOwner(resource.data.userId);
      
      // [SECURITY] Users can delete their own interactions (for cleanup)
      allow delete: if isAuthenticated() && isOwner(resource.data.userId);
    }
    
    // [SECURITY FIX] Reports - one-way write only
    match /reports/{reportId} {
      // [SECURITY] Reports are write-only, only admins can read (via backend)
      allow read: if false;
      
      allow create: if isAuthenticated()
        && isOwner(request.resource.data.reporterId)
        && isValidString(request.resource.data.reason, 10, 1000)
        && request.resource.data.reporterId is string
        && request.resource.data.reportedUserId is string
        && request.resource.data.reason is string
        && request.resource.data.createdAt == request.time;
      
      allow update, delete: if false;
    }
    
    // [SECURITY FIX] Deny all other collections by default
    match /{document=**} {
      allow read, write: if false;
    }
  }
}
